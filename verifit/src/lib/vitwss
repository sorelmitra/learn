#!/usr/bin/env python3

import os, sys, argparse, logging, asyncio, websockets, re

logging.basicConfig(stream=sys.stdout, level=logging.DEBUG)


class WebSocketsVerify:

    def __init__(self):
        super().__init__()
        self.args = {}
        self.LOG = None

    def reduce_url(self, url):
        m = re.match(r'(.*token=).*', url)
        if m:
            return f"{m.group(1)}[...]"
        return url

    async def send_async(self, socket_url, data):
        async with websockets.connect(socket_url) as websocket:
            await websocket.send(data)

    def send_sync(self, socket_url, data):
        asyncio.get_event_loop().run_until_complete(self.send_async(socket_url, data))

    async def receive_async(self, socket_url, ignore_list):
        async with websockets.connect(socket_url) as websocket:
            received = False
            while not received:
                data = await websocket.recv()
                self.LOG.debug(f"Received data is <{data}>")
                if data not in ignore_list:
                    received = True
        return data

    async def receive_async_with_timeout(self, socket_url, timeout_ms, ignore_list):
        seconds = timeout_ms / 1000
        try:
            result = await asyncio.wait_for(
                self.receive_async(socket_url, ignore_list),
                seconds
            )
            self.LOG.debug(f"Receive async result is <{result}>")
        except TimeoutError:
            result = f"Timed out waiting to receive data from {self.reduce_url(socket_url)}"
        return result

    def receive_sync_with_timeout(self, socket_url, timeout_ms, ignore_list):
        return asyncio.get_event_loop().run_until_complete(self.receive_async_with_timeout(socket_url, timeout_ms, ignore_list))

    def send(self):
        input_filename = self.args.input_file
        socket_url = self.args.socket_url
        self.LOG.info(f"Sending contents of {input_filename} to {self.reduce_url(socket_url)}")
        with open(input_filename, 'r') as myfile:
            data = myfile.read()
        self.send_sync(socket_url, data)

    def receive(self):
        packets_count = int(self.args.packets_to_receive)
        wait_ms = int(self.args.wait_ms)
        output_filename = self.args.output_file
        socket_url = self.args.socket_url
        ignore_list = self.args.ignore
        self.LOG.info(
            f"Receiving {packets_count} packets in {wait_ms} milliseconds from "
            f"{self.reduce_url(socket_url)} to {output_filename}; ignoring {ignore_list}")
        data = self.receive_sync_with_timeout(socket_url, wait_ms, ignore_list)
        with open(output_filename, 'w') as myfile:
            myfile.write(data)

    def run_with_args(self):
        ap = argparse.ArgumentParser(description="Verify It! WebSockets Secure test tool.")
        ap_subparsers = ap.add_subparsers(title="commands",
                                          description="Commands to either send or receive from WebSocket."
                                                      " Each command has its own arguments, "
                                                      "run it with '-h' to see them.",
                                          help="Valid commands.")

        # "send" subparser
        ap_sub_send = ap_subparsers.add_parser("send", help="Send given packet to the WebSocket and exit.")
        ap_sub_send.add_argument("--input-file", help="File whose contents to send to the socket", required=True)
        ap_sub_send.add_argument("socket_url", nargs="?")

        # "receive" subparser
        ap_sub_recv = ap_subparsers.add_parser("receive", help="Receive a number of packets in a timeout and exit.")
        ap_sub_recv.add_argument("--packets-to-receive", help="Number of packets to wait for, default ?.")
        ap_sub_recv.add_argument("--wait-ms",
                                 help="Number of milliseconds to wait for all packets to come in, default ?.")
        ap_sub_recv.add_argument("--ignore", help="Response(s) to ignore in the received packets.", action="append")
        ap_sub_recv.add_argument("--output-file",
                                 help="File to write incoming packets to, if not provided it writes to STDOUT.",
                                 required=True)
        ap_sub_recv.add_argument("socket_url", nargs="?")

        self.args = ap.parse_args()

        cmd_name = 'root'
        try:
            self.args.input_file
            cmd_name = 'send'
        except AttributeError:
            pass
        try:
            self.args.output_file
            cmd_name = 'receive'
        except AttributeError:
            pass

        self.LOG = logging.getLogger(cmd_name)
        self.LOG.debug(f"Arguments are {self.args}")
        if cmd_name == 'send':
            self.LOG.info(f"Started '{cmd_name}")
            self.send()
            self.LOG.info(f"Finished '{cmd_name}'")
        elif cmd_name == 'receive':
            self.LOG.info(f"Started '{cmd_name}'")
            self.receive()
            self.LOG.info(f"Finished '{cmd_name}'")
        else:
            print("\nMissing command!\n")
            ap.print_help()
            exit(1)


wsv = WebSocketsVerify()
wsv.run_with_args()
