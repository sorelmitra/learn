---
Mockito explained
---

https://stackoverflow.com/a/26319364/6239668

You're nesting mocking inside of mocking.  You're calling `getSomeList()`, which does some mocking, before you've finished the mocking for `MyMainModel`.  Mockito doesn't like it when you do this.

Replace

    @Test
    public myTest(){
        MyMainModel mainModel =  Mockito.mock(MyMainModel.class);
        Mockito.when(mainModel.getList()).thenReturn(getSomeList()); --> Line 355
    }


with

    @Test
    public myTest(){
        MyMainModel mainModel =  Mockito.mock(MyMainModel.class);
        List<SomeModel> someModelList = getSomeList();
        Mockito.when(mainModel.getList()).thenReturn(someModelList);
    }

To understand why this causes a problem, you need to know a little about how Mockito works, and also be aware in what order expressions and statements are evaluated in Java.

Mockito can't read your source code, so in order to figure out what you are asking it to do, it relies a lot on static state.  When you call a method on a mock object, Mockito records the details of the call in an internal list of invocations.  The `when` method reads the last of these invocations off the list and records this invocation in the `OngoingStubbing` object it returns.

The line

    Mockito.when(mainModel.getList()).thenReturn(someModelList);

causes the following interactions with Mockito:

* Mock method `mainModel.getList()` is called,
* Static method `when` is called,
* Method `thenReturn` is called on the `OngoingStubbing` object returned by the `when` method.

The `thenReturn` method can then instruct the mock it received via the `OngoingStubbing` method to handle any suitable call to the `getList` method to return `someModelList`.

In fact, as Mockito can't see your code, you can also write your mocking as follows:

    mainModel.getList();
    Mockito.when((List<SomeModel>)null).thenReturn(someModelList);

This style is somewhat less clear to read, especially since in this case the `null` has to be casted, but it generates the same sequence of interactions with Mockito and will achieve the same result as the line above.

However, the line 

    Mockito.when(mainModel.getList()).thenReturn(getSomeList());

causes the following interactions with Mockito:

1. Mock method `mainModel.getList()` is called,
2. Static method `when` is called,
3. A new `mock` of `SomeModel` is created (inside `getSomeList()`),
4. Mock method `model.getName()` is called,

At this point Mockito gets confused.  It thought you were mocking `mainModel.getList()`, but now you're telling it you want to mock the `model.getName()` method.  To Mockito, it looks like you're doing the following:

    when(mainModel.getList());
    // ...
    when(model.getName()).thenReturn(...);

This looks silly to `Mockito` as it can't be sure what you're doing with `mainModel.getList()`.

Note that we did not get to the `thenReturn` method call, as the JVM needs to evaluate the parameters to this method before it can call the method.  In this case, this means calling the `getSomeList()` method.

Generally it is a bad design decision to rely on static state, as Mockito does, because it can lead to cases where the Principle of Least Astonishment is violated.  However, Mockito's design does make for clear and expressive mocking, even if it leads to astonishment sometimes.

Finally, recent versions of Mockito add an extra line to the error message above.  This extra line indicates you may be in the same situation as this question:

> 3: you are stubbing the behaviour of another mock inside before 'thenReturn' instruction if completed


---
Mocking static methods
---

https://stackoverflow.com/a/21116014/6239668

Use [PowerMockito](https://github.com/jayway/powermock/wiki/MockitoUsage) on top of Mockito.

Example code:

    @RunWith(PowerMockRunner.class)
    @PrepareForTest(DriverManager.class)
    public class Mocker {
    
        @Test
        public void testName() throws Exception {
    
            //given
            PowerMockito.mockStatic(DriverManager.class);
            BDDMockito.given(DriverManager.getConnection(...)).willReturn(...);
    
            //when
            sut.execute();
    
            //then
            PowerMockito.verifyStatic();
            DriverManager.getConnection(...);
    
        }

More information:

* https://stackoverflow.com/questions/4482315/why-does-mockito-not-mock-static-methods

https://stackoverflow.com/a/21161006/6239668

Changing your `@PrepareForTest` annotation value to `MySQLDatabaseConnectionFactory.class` will resolve this issue.

> This annotation tells PowerMock to prepare certain classes for testing. Classes needed to be defined using this annotation are typically those that needs to be byte-code manipulated. This includes final classes, classes with final, private, static.

In this situation PowerMockito have to replace invocation to static method `DriverManager.getConnection` with mocked code. This is done with usage of byte-code manipulation.

Full code
--

    @RunWith(PowerMockRunner.class)
    @PrepareForTest(MySQLDatabaseConnectionFactory.class)
    public class MySQLDatabaseConnectionFactoryTest {
    
        private MySQLDatabaseConnectionFactory reference;
    
        @Before
        public void setUp() throws Exception {
            reference = new MySQLDatabaseConnectionFactory();
        }
    
        @Test
        public void testGetConnection() throws SQLException {
    
            // given
            PowerMockito.mockStatic(DriverManager.class);
            BDDMockito.given(DriverManager.getConnection(anyString(), anyString(), anyString()))
                 .willReturn(mock(Connection.class));
    
            // when
            reference.getConnection();
    
            // then
            PowerMockito.verifyStatic();
            DriverManager.getConnection("jdbc:mysql://myhost:1111/database", "username", "password");
        }
    }

*Thanks to [@Szpak](https://stackoverflow.com/users/313516/szpak) for helping me to resolve this issue!*

http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/BDDMockito.html

public class BDDMockito
extends Mockito
Behavior Driven Development style of writing tests uses //given //when //then comments as fundamental parts of your test methods. This is exactly how we write our tests and we warmly encourage you to do so!
Start learning about BDD here: http://en.wikipedia.org/wiki/Behavior_Driven_Development

The problem is that current stubbing api with canonical role of when word does not integrate nicely with //given //when //then comments. It's because stubbing belongs to given component of the test and not to the when component of the test. Hence BDDMockito class introduces an alias so that you stub method calls with given(Object) method. Now it really nicely integrates with the given component of a BDD style test!

Here is how the test might look like:


 import static org.mockito.BDDMockito.*;

 Seller seller = mock(Seller.class);
 Shop shop = new Shop(seller);

 public void shouldBuyBread() throws Exception {
   //given
   given(seller.askForBread()).willReturn(new Bread());

   //when
   Goods goods = shop.buyBread();

   //then
   assertThat(goods, containBread());
 }
 
Stubbing voids with throwables:

   //given
   willThrow(new RuntimeException("boo")).given(mock).foo();

   //when
   Result result = systemUnderTest.perform();

   //then
   assertEquals(failure, result);
 
For BDD style mock verification take a look at BDDMockito.Then in action:


   person.ride(bike);
   person.ride(bike);

   then(person).should(times(2)).ride(bike);
   then(person).shouldHaveNoMoreInteractions();
   then(police).shouldHaveZeroInteractions();
 
It is also possible to do BDD style InOrder verification:


   InOrder inOrder = inOrder(person);

   person.drive(car);
   person.ride(bike);
   person.ride(bike);

   then(person).should(inOrder).drive(car);
   then(person).should(inOrder, times(2)).ride(bike);
 
One of the purposes of BDDMockito is also to show how to tailor the mocking syntax to a different programming style.

Since:
1.8.0
