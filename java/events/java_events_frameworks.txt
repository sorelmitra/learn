1. Sources

Comparison of the various event frameworks:
[1] http://stackoverflow.com/questions/20663988/what-kind-of-eventbus-to-use-in-spring-built-in-reactor-akka

Spring's ApplicationEvent: 
[2] http://www.tutorialspoint.com/spring/custom_events_in_spring.htm
[2a] https://spring.io/blog/2015/02/11/better-application-events-in-spring-framework-4-2

AMQP:
[3] https://www.amqp.org/product/solve
[4] https://www.rabbitmq.com/java-client.html

JMS:
[5] http://docs.oracle.com/javaee/6/tutorial/doc/bncdx.html
[6] http://docs.oracle.com/javaee/6/tutorial/doc/bnceh.html

Reactor:
[7] https://github.com/reactor/reactor#reactor
[8] http://projectreactor.io/
[9] https://github.com/reactive-streams/reactive-streams-jvm

Streams and events:
[10] https://gist.github.com/jbrisbin/1444077
[11] http://maxogden.com/node-streams.html

AKKA
[12] http://akka.io/
[13] http://www.reactivemanifesto.org/
[14] http://www.lightbend.com/activator/template/akka-sample-main-java
[15] http://doc.akka.io/docs/akka/2.4.6/general/actors.html
[16] http://alexminnaar.com/introduction-to-the-multithreading-problem-and-the-akka-actor-solution.html

Java Lang
[17] https://en.wikipedia.org/wiki/Observer_pattern
[18] https://docs.oracle.com/javase/tutorial/uiswing/events/

Google Guava EventBus
[19] https://github.com/google/guava/wiki/EventBusExplained
[20] http://pmeade.blogspot.ro/2012/06/using-guava-eventbus-with-spring.html


2. What type of events do we have?

I) Internal, within the same app/JVM
II) Within the same machine but between different apps
III) Distributed, between different machines


3. Events Frameworks


A) Java Language: Type I, Coupled Event Listener and Producer

Write your own event mechanism using the Observer design pattern [17].
- Your code will end up with tightly coupled Subjects and Observers, like in Swing [18]. If multiple Subjects could fire the same event, then the Observers of that event would need to register which each Subject.
- Also, this is not responsive: it doesn't allow treating of new events while an existing event is under processing.

For anything more than this, you need a framework with a common event publishing mechanism to decouple the observers from their subjects, and with threads so new events can be at least queued during processing of others.


B) Spring's built-in ApplicationEvent: Type I

In [2a] it is stated: "Application events are available since the very beginning of the Spring framework as a mean for loosely coupled components to exchange information".
A comment from [2a] says with respect to Reactor - "Application events are not meant to support such event-based programming pattern anyway."

"ApplicationEvent is more used for bean life-cycle within the same application" - says [1], supported by [2].

ApplicationEvent is a simple event mechanism so that app components can communicate without knowing of each other. It looks to me it has three components: a publisher that is used to publish events, a producer that uses the publisher to produce events, and a consumer that registers with the publisher to receive events.
This solves the coupling problem from the Java Language solution.

For the responsiveness problem, you would still need to implement a "service" using some of Spring's task execution mechanisms.


C) Google Guava EventBus

This looks to me similar to Sping's ApplicationEvent, it provides the same basic features, but differently named: an event bus to publish events, a listener that registers with the event bus, and a publisher that uses event bus to publish events [19].

Similarly to Spring, you need to use Guava Services to solve the responsiveness problem. Of course you could use any other threading/scheduling mechanism, including Spring's own one.

Pointer on how to integrate it with Spring Beans: [20].


D) Reactor: Type I

Reactor is "A set of foundational libraries for building reactive cloud-ready applications on the JVM." [7]
From [8] and [9]: "Create efficient Reactive systems - Reactor is a second-generation Reactive library for building non-blocking applications on the JVM based on the Reactive Streams Specification".
Reactive Streams Specification: "The main goal of Reactive Streams is to govern the exchange of stream data across an asynchronous boundary – think passing elements on to another thread or thread-pool — while ensuring that the receiving side is not forced to buffer arbitrary amounts of data. The benefits of asynchronous processing would be negated if the communication of backpressure were synchronous (see also the Reactive Manifesto), therefore care has been taken to mandate fully non-blocking and asynchronous behavior of all aspects of a Reactive Streams implementation."

This means that Reactor has a model similar to a traditional server: A primary thread that listens for events that are passed to other (newly-created or already existing) threads to do the actual processing.
It looks like Reactor lets the programmer decide how many threads to use.

Based on Reactor, some guy [10] had an idea to mix its model with the single-threaded model of node.js in order to avoid concurency issues: he tried to develop (but never publish it?) "an easy-to-use programming model that removes the necessity to use synchronization and worry about concurrency issues, while making it easy to respond to events in multiple threads if it's more efficient for your application to do so (unlike the strict single-threadedness of Node.js, this framework gives you a choice of single-threaded efficiency or multi-threaded parallelism)."
A short explanation on how Node.JS does streams using events is in [11].


E) Akka: Type I

"Akka is a toolkit and runtime for building highly concurrent, distributed, and resilient message-driven applications on the JVM. The power of Akka is also available on the .NET Framework and Mono via the Akka.NET project." [12]

Akka follows the Reactive Manifesto [13], as Reactor does, but it looks to be more general - Reactor seems to be focused on streams. Also, Akka introduces a higher level of abstraction using actors.

The main Akka building blocks are Actors. I think they are threads [14] - when the HelloWorld actor stops by calling getContext().stop(), the whole app stops.
Actors communicate to each other by sending messages.

I think Akka is similar to Reactor - using multiple threads for events processing, but:
"Behind the scenes Akka will run sets of actors on sets of real threads, where typically many actors share one thread, and subsequent invocations of one actor may end up being processed on different threads. Akka ensures that this implementation detail does not affect the single-threadedness of handling the actor’s state."
So Akka offers little control about threads themselves. It does ensure you that an Actor processes messages in queue (is single-threaded) [15], [16].


F) JMS - Java Messaging System: Type III

In [1] it is stated that JMS is more for distributed systems, although I imagine it can be used within the same app. But [6] proves that if you have a single app, JMS is overkill.


G) AMQP - Advanced Message Queuing Protocol: Type III

This is a general protocol for distributed systems.
Java can use it via Spring or RabbitMQ [4].
